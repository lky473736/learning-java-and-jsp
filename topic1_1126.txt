<자바 시작하기>
- 자바 : tiobe index에서 4위 차지한 언어
- 일단은 자바를 공부하기 전, 내가 자바를 그렇게 좋아하지 않는 이유를 알아보자면,
	- 자바는 명령어, 구문 하나하나가 너무 길다
		- 예를 들어서, 출력만 해도 System.out.println, 입력은 또 버퍼를 이용하는 방법, 시스템 상 입력 등... 너무 쓸데 없이 김
		- 이게 다 자바의 견고함을 위해서 그런거다라고 하지만, 굳이 이래야 하는가?
	- 뭐가 되게 많다
		- JVM이라고 하는 기술을 포함하고 있음
			- 운영체제에 종속되지 않고 자바 버추얼 머신에 자바 코드를 올려놓기만 하면 어느 os에서도 동작 가능하게 하는 기술 -> 이건 좋다 
			- 근데 왜 이렇게 디렉토리 구조를 복잡하게 하냐는 말임
- 그러면 자바를 왜 배워야 할까
	- 대한민국은 자바공화국
		- 물론 난 ai 쪽으로 연구할 거지만, 정부표준이 모두 자바로 이루어진 대한민국에서 자바 관련 프레임워크를 모르는 건 조금 난감해질 수 있다고 생각
		- 결국 스프링을 다뤄야 할 텐데 자바 몰라서는 안될 듯
	- 그래도 범세계적으로 많이 사용하는 언어이기 때문에
		- 보통 software engineer라고 한다면 서버 프로그래밍을 할 텐데, 여기서 가장 많이 사용되는게 자바니깐
		
<자바의 특징>
- 간결하면서 강력한 객체지향
	- 간결하다고? 인정 못함
- 플랫폼 독립적 
	- JVM 때문에
- 오픈소스 라이브러리 많음, 생산성 향상, 유지보수 비용 절감
	- 오픈소스 : 톰캣, 스프링 프레임워크 등
	- 생산성 향상 : 소켓, 스프링
	- 유지보수 : 다양한 디자인 패턴을 적용할 수 있음
- 스프링 프레임워크 있어서 대규모 시스템개발에 적합함
- GUI에는 적합 안함 
	- GUI에는 보통은 qt와 같은 C++이나, pyqt 지닌 python이 더 적합
	- 최신 프로그래밍 언어보다 간결함 떨어지고 불필요한게 많은데, 이거는 java8 이후에 업데이트되고 있지만 그래도 쓰레기같음
	
<자바의 역사>
- 자바 탄생 (1995년 Sun에서 제임스 고슬링이 개발)
	- 가상머신 (JVM) : 플랫폼 독립적인 구현
	- 객체지향 
	- 인터넷, 웹 발전과 함께함
- 서블릿과 JSP (1997)
	- 자바 + 웹
	- 서블릿이 이때 인기가 되게 많았음
	- JSP = HTML + Java -> 개발 효율성 높임
	- 웹 개발의 기본 기술이었으나 프론트, 백 개발환경의 변화로 인해 예전보다 많이 사용 안함
- 이클립스 (1999)
	- IBM의 오픈소스 IDE
	- 이클립스가 자바만 지원하지는 않음. 그냥 자바 개발하기 편한거지
	- 요즘에는 인텔리제이가 좋음 (안드로이드 스튜디오 때문에) 
- 모바일 인터넷 (2000년 초중반)
	- 스마트폰 보급 -> 여기에 JVM을 탑재하자 
	- 근데 휴대폰 사양이 안좋아서 성장 못함
- 안드로이드 (2007)
	- 구글이 안드로이드 발표, OS커널은 리눅스지만 응용프로그램 개발의 기본을 자바로 채택함
	- 오라클과의 라이선스 문제 때문에 내장 가상머신 변화 및 kotlin으로의 이동 가속화됨
- 스프링프레임워크 
	- 2002년에 나온 J2EE 책에 기반하여 2004년에 1.0 발표함
	- 스프링부트로인해 개발이 간소화
	- 대규모 시스템 개발에 적합한 오픈소스 프레임워크
	- 요즘에 전자정부프레임워크 == 스프링 기반
		- 이래서 "자바공화국"
- 상용화
	- 2019년부터 자바 상용화, 일반적 목적의 경우 계속 무료로 사용 가능
	- 만약 임베디드나 상업용, 업무용 목적이면 별도 라이선스 필요
	- 기업에서 무료로 자바 사용하려면 OpenJDK사용해야 함
	
<자바 활용 분야>
- 백엔드 서비스 개발
- spring framework -> 기업 시스템 개발
- 안드로이드의 대표 언어 -> 지금은 Kotlin, React Native, Flutter 등으로 많은 변화 예상
- 빅데이터, 머신러닝, 인공지능 기반 기술들에 자바 기반 소프트웨어들이 널리 사용
	- 난 이게 정말 짜증나는게, 말도 안되는 소리이기 때문
	- 자바로 머신러닝을 한다고? 
		- 이전에 언급하였듯이, 핸드폰의 사양이 안되어서 JVM이 못들어가서 자바 개발이 점차 줄어들었다고 했는데, 그러면 ai가 사용되어야 할 다른 기기는 사양이 좋아서 자바가 들어가는가?
		- 말도 안되는 말이다.

<가상머신과 JDK>
- 소스코드 (.java) -> javac -> byte code (.class) -> java
- 바이트 코드 : 자바 컴파일러가 생성하는 코드, 기계어가 아니라 JVM에 의해 해석될 수 있는 일종의 중간 코드 개념임
	- 자바 언어가 아니더라도 동일한 바이트코드를 생성 가능하면 동일한 JVM에서 실행 가능할 것임
- JVM : 소프트웨어로 구현된 기계장치, OAK 프로젝트에서 나온 아이디어, 자바소스가 컴파일되면 바이트코드가 되는데, 그걸 해석하고 운영체제에서 실행할 수 있도록 번역해줌
	- 가상머신이라는 개념을 자바가 만든건 아니고, 실제로 성공한 프로젝트가 자바가 대표적 -> 하드웨어나 운영체제 영향 안받고 동일한 프로그램의 개발과 실행이 가능함
	- WORA
	- .Net 플랫폼에도 영향을 미침 -> Kotlin, Scala, Clojure와 같은 JVM 기반 언어들도 유행함 (언어의 문법은 서로 달라도 자바와 같은 바이트코드 생성함)
	
<JVM 아키텍처>
- 클래스 로더, 런타임 데이터 영역, 실행 엔진으로 구분
- 클래스 로더
	- 바이트 코드를 메모리에 로딩 
	- 바이트코드로 구성된 클래스 파일 읽어들여 초기화하고 다음 런타임 데이터 영역에 배치
- 런타임 데이터 영역
	- 실행중인 데이터 저장 공간
	- method, heap, stack으로 구분
		- method : 모든 쓰레드가 공유하는 영역 (클래스, 메소드, 변수, 타입, 접근제어자, static 변수가 저장됨)
		- heap : 모든 쓰레드가 공유하는 영역 (레퍼런스 타입을 포함한 객체, 인스턴스 저장)
		- stack : 쓰레드 단위로 관리, 메소드 호출에 따른 변수 사용 등 메모리 할당
	- PC 레지스터 : 현재 실행중인 JVM 명령의 주소 저장 레지스터 (일종의 버퍼메모리)
- 실행 엔진
	- 클래스 로더 통해 런타임 영역에 배치된 바이트코드를 명령어단위로 읽어서 실행 (인터프리터 방식과 JIT 컴파일러 방식을 혼용하여 사용함)
		- JIT 컴파일러는 바이트 코드 전체를 컴파일 -> 네이티브 코드로 변환 -> 캐시에 저장해 놓아서 반복적 실행에 대한 성능 향상
- JNI
	- 자바프로그램이 다른 언어로 작성된 코드를 호출하거나 다른 언어로 작성된 프로그램이 자바메소드를 호출할 수 있도록 하는 프레임워크
	- NDK와 비슷함
	
<JDK>
- 자바를 위한 개발키트, 컴파일러와 디버거가 들어있음
- JRE만으로 자바 실행 가능하기는 하지만 자바 프로그램을 개발하기 위해선 JDK가 필요
- eclipse, intelij와 같은 IDE에서는 JDK 필요함
- LTS

<자바 메모리 관리>
- method
	- 다음 클래스에 대한 정보 저장
	- 클래스, 인터페이스, 메소드, 필드, static 변수 여기에 생성 (모든 쓰레드 공유)
	- main()에서 클래스에 선언된 변수에 접근할 수 없는 이유
		- main()이 static으로 선언되어있기 때문에 클래스에 선언된 멤버변수를 사용할 수 없는 것임
		- 인스턴스의 변수들은 힙 영역 생성 -> 인스턴스 통해서만 접근이 가능함
- heap
	- 인스턴스는 이곳에 생성 (프로그램의 대부분의 공간은 heap)
	- 가비지 컬렉터에 의하여 관리됨 (더이상 사용 안되는 객체 정리)
	- 힙 메모리가 부족하다면 JVM 메모리 옵션 조정해주면 됨
	
- stack
	- 메소드 실행에 사용되는 메모리 공간
	- 메소드 호출 -> 스택에 호출된 메소드 위한 메모리 할당 -> 메소드 수행 도중 지역변수나 매개변수의 연산 중간결과 등을 저장하는데 사용
	- 메소드가 작업 끝나면 메모리공간 반환됨
	- 이래서 지역변수들이 멤버변수와 이름이 같아도 문제 없는 이유
	- 쓰레드 독립적으로 관리
	
- GC
	- 자바에서 사용되지 않는 메모리 정리
	- JVM의 성능에 영향을 미침
	- 컨테이너 기반에서 동작하는 프로그램이면 별로 신경 안써도 됨
		- System.gc()를 이용해 가비지 컬렉션 동작 가능한데 이거 별로 권장 안됨
	- GC의 대상
		- 모든 객체참조가 null
		- 객체가 블럭 안에서 생성 후 종료된 경우
		- 부모 객체가 null된 경우, 자식 객체가 GC대상
		- Weak 참조만 가질 때
		- Soft 참조지만 메모리부족이면